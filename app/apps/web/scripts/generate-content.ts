/**
 * Content Generation Script
 *
 * This script pre-generates all MDX content at build time
 * so it can be imported statically without runtime fs calls.
 *
 * Run: npx tsx scripts/generate-content.ts
 */

import fs from "fs";
import path from "path";
import matter from "gray-matter";

const contentDirectory = path.join(process.cwd(), "..", "..", "content");
const outputDirectory = path.join(process.cwd(), "lib", "generated");

interface DocPage {
  slug: string;
  title: string;
  description: string;
  order: number;
  section?: string;
  content: string;
}

interface BlogPost {
  slug: string;
  title: string;
  description: string;
  date: string;
  author: string;
  authorImage?: string;
  authorBio?: string;
  image?: string;
  tags: string[];
  published: boolean;
  content: string;
  readingTime: string;
}

function calculateReadingTime(content: string): string {
  const wordsPerMinute = 200;
  const words = content.trim().split(/\s+/).length;
  const minutes = Math.ceil(words / wordsPerMinute);
  return `${minutes} min read`;
}

function getAllDocPages(): DocPage[] {
  const docsDir = path.join(contentDirectory, "docs");

  if (!fs.existsSync(docsDir)) {
    return [];
  }

  function getDocsRecursively(dir: string, basePath = ""): DocPage[] {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    const pages: DocPage[] = [];

    for (const entry of entries) {
      if (entry.isDirectory()) {
        const subPages = getDocsRecursively(
          path.join(dir, entry.name),
          `${basePath}${entry.name}/`
        );
        pages.push(...subPages);
      } else if (entry.name.endsWith(".mdx")) {
        const filePath = path.join(dir, entry.name);
        const fileContents = fs.readFileSync(filePath, "utf8");
        const { data, content } = matter(fileContents);
        const slug = `${basePath}${entry.name.replace(".mdx", "")}`;

        pages.push({
          slug,
          title: data.title ?? "Untitled",
          description: data.description ?? "",
          order: data.order ?? 999,
          section: data.section,
          content,
        });
      }
    }

    return pages;
  }

  return getDocsRecursively(docsDir).sort((a, b) => a.order - b.order);
}

function getAllBlogPosts(): BlogPost[] {
  const blogDir = path.join(contentDirectory, "blog");

  if (!fs.existsSync(blogDir)) {
    return [];
  }

  const files = fs.readdirSync(blogDir).filter((f) => f.endsWith(".mdx"));

  const posts = files.map((filename) => {
    const filePath = path.join(blogDir, filename);
    const fileContents = fs.readFileSync(filePath, "utf8");
    const { data, content } = matter(fileContents);

    return {
      slug: filename.replace(".mdx", ""),
      title: data.title ?? "Untitled",
      description: data.description ?? "",
      date: data.date ?? new Date().toISOString(),
      author: data.author ?? "Anonymous",
      authorImage: data.authorImage,
      authorBio: data.authorBio,
      image: data.image,
      tags: data.tags ?? [],
      published: data.published !== false,
      content,
      readingTime: calculateReadingTime(content),
    } as BlogPost;
  });

  return posts
    .filter((p) => p.published)
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

function main() {
  // Ensure output directory exists
  if (!fs.existsSync(outputDirectory)) {
    fs.mkdirSync(outputDirectory, { recursive: true });
  }

  // Generate docs content
  const docs = getAllDocPages();
  const docsMap: Record<string, DocPage> = {};
  for (const doc of docs) {
    docsMap[doc.slug] = doc;
  }

  const docsOutput = `// Auto-generated file - do not edit manually
// Generated by: npx tsx scripts/generate-content.ts

export interface DocPage {
  slug: string;
  title: string;
  description: string;
  order: number;
  section?: string;
  content: string;
}

export const allDocPages: DocPage[] = ${JSON.stringify(docs, null, 2)};

export const docPagesBySlug: Record<string, DocPage> = ${JSON.stringify(docsMap, null, 2)};

export function getDocPage(slug: string): DocPage | null {
  return docPagesBySlug[slug] ?? null;
}

export function getAllDocPages(): DocPage[] {
  return allDocPages;
}
`;

  fs.writeFileSync(path.join(outputDirectory, "docs.ts"), docsOutput);
  console.log(`âœ… Generated ${docs.length} doc pages`);

  // Generate blog content
  const posts = getAllBlogPosts();
  const postsMap: Record<string, BlogPost> = {};
  for (const post of posts) {
    postsMap[post.slug] = post;
  }

  // Collect all tags
  const allTags = new Set<string>();
  for (const post of posts) {
    for (const tag of post.tags) {
      allTags.add(tag);
    }
  }

  const blogOutput = `// Auto-generated file - do not edit manually
// Generated by: npx tsx scripts/generate-content.ts

export interface BlogPost {
  slug: string;
  title: string;
  description: string;
  date: string;
  author: string;
  authorImage?: string;
  authorBio?: string;
  image?: string;
  tags: string[];
  published: boolean;
  content: string;
  readingTime: string;
}

export const allBlogPosts: BlogPost[] = ${JSON.stringify(posts, null, 2)};

export const blogPostsBySlug: Record<string, BlogPost> = ${JSON.stringify(postsMap, null, 2)};

export const allTags: string[] = ${JSON.stringify(Array.from(allTags).sort(), null, 2)};

export function getBlogPost(slug: string): BlogPost | null {
  return blogPostsBySlug[slug] ?? null;
}

export function getAllBlogPosts(): BlogPost[] {
  return allBlogPosts;
}

export function getAllTags(): string[] {
  return allTags;
}

export function getRelatedPosts(currentSlug: string, limit = 3): BlogPost[] {
  const currentPost = blogPostsBySlug[currentSlug];
  if (!currentPost) return [];

  const scoredPosts = allBlogPosts
    .filter((p) => p.slug !== currentSlug)
    .map((post) => {
      const sharedTags = post.tags.filter((tag) => currentPost.tags.includes(tag));
      return { post, score: sharedTags.length };
    })
    .filter((item) => item.score > 0)
    .sort((a, b) => b.score - a.score);

  if (scoredPosts.length === 0) {
    return allBlogPosts.filter((p) => p.slug !== currentSlug).slice(0, limit);
  }

  return scoredPosts.slice(0, limit).map((item) => item.post);
}
`;

  fs.writeFileSync(path.join(outputDirectory, "blog.ts"), blogOutput);
  console.log(`âœ… Generated ${posts.length} blog posts`);
  console.log(`âœ… Generated ${allTags.size} tags`);

  console.log("\nðŸ“¦ Content generation complete!");
}

main();
